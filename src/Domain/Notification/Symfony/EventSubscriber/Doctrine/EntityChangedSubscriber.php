<?php

declare(strict_types=1);

namespace App\Domain\Notification\Symfony\EventSubscriber\Doctrine;

use App\Domain\Documentation\Model\Document;
use App\Domain\Notification\Model\Notification;
use App\Domain\Registry\Model\Contractor;
use App\Domain\Registry\Model\Mesurement;
use App\Domain\Registry\Model\Proof;
use App\Domain\Registry\Model\Request;
use App\Domain\Registry\Model\Treatment;
use App\Domain\Registry\Model\Violation;
use App\Domain\User\Model\User;
use App\Domain\User\Repository\User as UserRepository;
use App\Infrastructure\ORM\Notification\Repository\Notification as NotificationRepository;
use Doctrine\Common\EventSubscriber;
use Doctrine\ORM\Event\OnFlushEventArgs;
use Doctrine\ORM\Events;
use Symfony\Component\Security\Core\Security;
use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

/**
 * This subscriber handles events that are generated by doctrine, and creates notifications from them if necessary.
 */
class EntityChangedSubscriber implements EventSubscriber
{
    protected array $classes = [
        Treatment::class,
        Mesurement::class,
        Violation::class,
        Proof::class,
        Contractor::class,
        Request::class,
        Document::class,
    ];

    protected array $recipients = [
        Treatment::class  => Notification::NOTIFICATION_DPO,
        Mesurement::class => Notification::NOTIFICATION_DPO,
        Violation::class  => Notification::NOTIFICATION_DPO,
        Proof::class      => Notification::NOTIFICATION_DPO,
        Contractor::class => Notification::NOTIFICATION_DPO,
        Request::class    => Notification::NOTIFICATION_DPO,
        Document::class   => Notification::NOTIFICATION_COLLECTIVITY,
    ];

    protected NotificationRepository $notificationRepository;
    protected NormalizerInterface $normalizer;
    protected UserRepository $userRepository;
    protected Security $security;

    public function __construct(
        NotificationRepository $notificationRepository,
        NormalizerInterface $normalizer,
        UserRepository $userRepository,
        Security $security
    ) {
        $this->notificationRepository = $notificationRepository;
        $this->normalizer             = $normalizer;
        $this->userRepository         = $userRepository;
        $this->security               = $security;
    }

    public function getSubscribedEvents(): array
    {
        return [
            Events::onFlush,
        ];
    }

    public function onFlush(OnFlushEventArgs $eventArgs)
    {
        $em  = $eventArgs->getEntityManager();
        $uow = $em->getUnitOfWork();

        foreach ($uow->getScheduledEntityInsertions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class === $class) {
                continue;
            }

            $notifications = $this->createNotifications($entity, 'create');
            $meta          = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);
            foreach ($notifications as $notif) {
                $this->notificationRepository->persist($notif);

                $uow->computeChangeSet($meta, $notif);
            }
        }

        foreach ($uow->getScheduledEntityUpdates() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Document::class === $class) {
                continue;
            }
            $ch = $uow->getEntityChangeSet($entity);
            if (Request::class === $class && !isset($ch['state'])) {
                // Exit if the request has no state change
                continue;
            }
            $action = 'update';
            if (Request::class === $class) {
                $action = 'state_change';
            }
            $notifications = $this->createNotifications($entity, $action);
            $meta          = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);

            foreach ($notifications as $notif) {
                $this->notificationRepository->persist($notif);

                $uow->computeChangeSet($meta, $notif);
            }
        }

        foreach ($uow->getScheduledEntityDeletions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class == $class || Document::class === $class) {
                continue;
            }

            $this->createNotifications($entity, 'delete');
        }
    }

    private function createNotifications($object, $action): array
    {
        // for each user
        // Check if this notification applies to them
        // create a notification for them if they are not DPO
        // Otherwise create a notification with user_id null
        $notifications = [];
        $recipients    = $this->recipients[get_class($object)];

        $normalized = $this->normalizer->normalize($object, null, array_merge(
            [
                AbstractObjectNormalizer::CIRCULAR_REFERENCE_HANDLER => function ($o) {return $o->getId(); },
                AbstractObjectNormalizer::ENABLE_MAX_DEPTH           => true,
                AbstractObjectNormalizer::CIRCULAR_REFERENCE_LIMIT   => 1,
                AbstractObjectNormalizer::MAX_DEPTH_HANDLER          => function ($o) {return $o->getId(); },
            ],
            $this->setMaxDepth($object)
        ));

        if ($recipients & Notification::NOTIFICATION_DPO) {
            $notification    = $this->createNotificationForUser($object, $action, $normalized);
            $notifications[] = $notification;
        }

        if ($recipients & Notification::NOTIFICATION_COLLECTIVITY) {
            // get all non-DPO users
            $users = $this->userRepository->findNonDpoUsers();
            foreach ($users as $user) {
                $notification    = $this->createNotificationForUser($object, $action, $normalized, $user);
                $notifications[] = $notification;
            }
        }

        return $notifications;
    }

    private function createNotificationForUser($object, $action, $normalized, ?User $user = null): Notification
    {
        $notification = new Notification();
        $mod          = Notification::MODULES[get_class($object)];
        $notification->setModule('notification.modules.' . $mod);
        $notification->setCollectivity(method_exists($object, 'getCollectivity') ? $object->getCollectivity() : null);
        $notification->setName(method_exists($object, 'getName') ? $object->getName() : $object->__toString());
        $notification->setAction('notification.actions.' . $action);
        $notification->setCreatedBy($this->security->getUser());
        $notification->setUser($user);
        $notification->setObject((object) $normalized);

        return $notification;
    }

    private function setMaxDepth($object)
    {
        $depths = [];
        $class = get_class($object);
        $methods = get_class_methods($class);
        foreach ($methods as $method) {
            if (substr($method, 0, 3) === "get") {
                $property = lcfirst(substr($method, 3));
                $depths['depth_'.$class.'::'.$property] = 0;
            }
        }


        return $depths;
    }
}
