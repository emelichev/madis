<?php

declare(strict_types=1);

namespace App\Domain\Notification\Symfony\EventSubscriber\Doctrine;

use App\Domain\Documentation\Model\Document;
use App\Domain\Notification\Model\Notification;
use App\Domain\Registry\Model\Contractor;
use App\Domain\Registry\Model\Mesurement;
use App\Domain\Registry\Model\Proof;
use App\Domain\Registry\Model\Request;
use App\Domain\Registry\Model\Treatment;
use App\Domain\Registry\Model\Violation;
use App\Domain\User\Repository\User as UserRepository;
use App\Infrastructure\ORM\Notification\Repository\Notification as NotificationRepository;
use Doctrine\Common\EventSubscriber;
use Doctrine\ORM\Event\OnFlushEventArgs;
use Doctrine\ORM\Events;
use Symfony\Component\Security\Core\Security;
use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
use Symfony\Component\Serializer\SerializerInterface;

/**
 * This subscriber handles events that are generated by doctrine, and creates notifications from them if necessary.
 */
class EntityChangedSubscriber implements EventSubscriber
{
    protected array $classes = [
        Treatment::class,
        Mesurement::class,
        Violation::class,
        Proof::class,
        Contractor::class,
        Request::class,
        Document::class,
    ];

    protected array $modules = [
        Treatment::class  => 'treatment',
        Mesurement::class => 'action',
        Violation::class  => 'violation',
        Proof::class      => 'proof',
        Contractor::class => 'contractor',
        Document::class   => 'documentation',
    ];

    protected NotificationRepository $notificationRepository;
    protected SerializerInterface $serializer;
    protected UserRepository $userRepository;
    protected Security $security;

    public function __construct(
        NotificationRepository $notificationRepository,
        SerializerInterface $serializer,
        UserRepository $userRepository,
        Security $security
    ) {
        $this->notificationRepository = $notificationRepository;
        $this->serializer             = $serializer;
        $this->userRepository         = $userRepository;
        $this->security               = $security;
    }

    public function getSubscribedEvents(): array
    {
        return [
            Events::onFlush,
        ];
    }

    public function onFlush(OnFlushEventArgs $eventArgs)
    {
        $em  = $eventArgs->getEntityManager();
        $uow = $em->getUnitOfWork();

        foreach ($uow->getScheduledEntityInsertions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class === $class) {
                continue;
            }

            $notif = $this->createNotification($entity, 'create');

            $this->notificationRepository->persist($notif);
            $meta = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);
            $uow->computeChangeSet($meta, $notif);
        }

        foreach ($uow->getScheduledEntityUpdates() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Document::class === $class) {
                continue;
            }
            $ch = $uow->getEntityChangeSet($entity);
            if (Request::class === $class && !isset($ch['state'])) {
                // Exit if the request has no state change
                continue;
            }
            $action = 'update';
            if (Request::class === $class) {
                $action = 'state_change';
            }
            $notif = $this->createNotification($entity, $action);

            $this->notificationRepository->persist($notif);
            $meta = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);
            $uow->computeChangeSet($meta, $notif);
        }

        foreach ($uow->getScheduledEntityDeletions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class == $class || Document::class === $class) {
                continue;
            }

            $this->createNotification($entity, 'delete');
        }
    }

    private function createNotification($object, $action): Notification
    {
        $notification = new Notification();
        $mod          = $this->modules[get_class($object)];
        $notification->setModule('notification.modules.' . $mod);
        $notification->setCollectivity($object->getCollectivity());
        $notification->setName(method_exists($object, 'getName') ? $object->getName() : $object->__toString());
        $notification->setAction('notification.actions.' . $action);
        $notification->setCreatedBy($this->security->getUser());
        $notification->setObject($this->serializer->normalize($object, null, [
            AbstractObjectNormalizer::CIRCULAR_REFERENCE_HANDLER => function ($o) {return $o->getId(); },
            AbstractObjectNormalizer::ENABLE_MAX_DEPTH                 => true,
            'depth_App\Domain\Registry\Model\Request::proofs'          => 1,
            'depth_App\Domain\Registry\Model\Request::applicant'       => 1,
            'depth_App\Domain\Registry\Model\Request::concernedPeople' => 1,
            'depth_App\Domain\Registry\Model\Request::answer'          => 1,
            'depth_App\Domain\Registry\Model\Request::service'         => 1,
            'depth_App\Domain\Registry\Model\Request::mesurements'     => 1,
            AbstractObjectNormalizer::CIRCULAR_REFERENCE_LIMIT         => 2,
        ]));

        return $notification;
    }
}
