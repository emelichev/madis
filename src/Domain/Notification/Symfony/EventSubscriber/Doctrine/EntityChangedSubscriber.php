<?php

declare(strict_types=1);

namespace App\Domain\Notification\Symfony\EventSubscriber\Doctrine;

use App\Domain\Documentation\Model\Document;
use App\Domain\Notification\Model\Notification;
use App\Domain\Registry\Model\Contractor;
use App\Domain\Registry\Model\Mesurement;
use App\Domain\Registry\Model\Proof;
use App\Domain\Registry\Model\Request;
use App\Domain\Registry\Model\Treatment;
use App\Domain\Registry\Model\Violation;
use App\Domain\User\Model\User;
use App\Domain\User\Repository\User as UserRepository;
use App\Infrastructure\ORM\Notification\Repository\Notification as NotificationRepository;
use Doctrine\Common\EventSubscriber;
use Doctrine\ORM\Event\OnFlushEventArgs;
use Doctrine\ORM\Events;
use Symfony\Component\Security\Core\Security;
use Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer;
use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

/**
 * This subscriber handles events that are generated by doctrine, and creates notifications from them if necessary.
 */
class EntityChangedSubscriber implements EventSubscriber
{
    protected array $classes = [
        Treatment::class,
        Mesurement::class,
        Violation::class,
        Proof::class,
        Contractor::class,
        Request::class,
        Document::class,
    ];

    protected array $recipients = [
        Treatment::class  => Notification::NOTIFICATION_DPO,
        Mesurement::class => Notification::NOTIFICATION_DPO,
        Violation::class  => Notification::NOTIFICATION_DPO,
        Proof::class      => Notification::NOTIFICATION_DPO,
        Contractor::class => Notification::NOTIFICATION_DPO,
        Request::class    => Notification::NOTIFICATION_DPO,
        Document::class   => Notification::NOTIFICATION_COLLECTIVITY,
    ];

    protected NotificationRepository $notificationRepository;
    protected UserRepository $userRepository;
    protected Security $security;
    protected NormalizerInterface $normalizer;

    public function __construct(
        NotificationRepository $notificationRepository,
        NormalizerInterface $normalizer,
        UserRepository $userRepository,
        Security $security
    ) {
        $this->notificationRepository = $notificationRepository;
        $this->normalizer             = $normalizer;
        $this->userRepository         = $userRepository;
        $this->security               = $security;
    }

    public function getSubscribedEvents(): array
    {
        return [
            Events::onFlush,
        ];
    }

    public function onFlush(OnFlushEventArgs $eventArgs)
    {
        $em  = $eventArgs->getEntityManager();
        $uow = $em->getUnitOfWork();

        foreach ($uow->getScheduledEntityInsertions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class === $class) {
                continue;
            }

            $notifications = $this->createNotifications($entity, 'create');
            $meta          = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);
            foreach ($notifications as $notif) {
                $this->notificationRepository->persist($notif);

                $uow->computeChangeSet($meta, $notif);
            }
        }

        foreach ($uow->getScheduledEntityUpdates() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Document::class === $class) {
                continue;
            }
            $ch = $uow->getEntityChangeSet($entity);
            if (Request::class === $class && !isset($ch['state'])) {
                // Exit if the request has no state change
                continue;
            }
            $action = 'update';
            if (Request::class === $class) {
                $action = 'state_change';
            }
            $notifications = $this->createNotifications($entity, $action);
            $meta          = $eventArgs->getEntityManager()->getClassMetadata(Notification::class);

            foreach ($notifications as $notif) {
                $this->notificationRepository->persist($notif);

                $uow->computeChangeSet($meta, $notif);
            }
        }

        foreach ($uow->getScheduledEntityDeletions() as $entity) {
            $class = get_class($entity);
            if (!in_array($class, $this->classes) || Request::class == $class || Document::class === $class) {
                continue;
            }

            $this->createNotifications($entity, 'delete');
        }
    }

    private function createNotifications($object, $action): array
    {
        // for each user
        // Check if this notification applies to them
        // create a notification for them if they are not DPO
        // Otherwise create a notification with user_id null
        $notifications = [];
        $recipients    = $this->recipients[get_class($object)];

        $normalized = $this->normalizer->normalize($object, null,
            [
                AbstractObjectNormalizer::CIRCULAR_REFERENCE_HANDLER => function ($o) {
                    return $this->getObjectSimpleValue($o);
                },
                AbstractObjectNormalizer::ENABLE_MAX_DEPTH           => true,
                AbstractObjectNormalizer::CIRCULAR_REFERENCE_LIMIT   => 1,
                AbstractObjectNormalizer::MAX_DEPTH_HANDLER          => function ($o) {
                    if (is_iterable($o)) {
                        $d = [];
                        foreach ($o as $item) {
                            $d[] = $this->getObjectSimpleValue($item);
                        }

                        return $d;
                    }

                    return $this->getObjectSimpleValue($o);
                },
            ],
        );

        if (Treatment::class === get_class($object)) {
            //dd(get_class($this->normalizer));
        }

        if ($recipients & Notification::NOTIFICATION_DPO) {
            $notification    = $this->createNotificationForUsers($object, $action, $normalized);
            $notifications[] = $notification;
        }

        if ($recipients & Notification::NOTIFICATION_COLLECTIVITY) {
            // get all non-DPO users
            $users = $this->userRepository->findNonDpoUsers();
            foreach ($users as $user) {
                $notification    = $this->createNotificationForUsers($object, $action, $normalized, $users);
                $notifications[] = $notification;
            }
        }

        return $notifications;
    }

    private function createNotificationForUsers($object, $action, $normalized, $users = null): Notification
    {
        $notification = new Notification();
        $mod          = Notification::MODULES[get_class($object)];
        $notification->setModule('notification.modules.' . $mod);
        $notification->setCollectivity(method_exists($object, 'getCollectivity') ? $object->getCollectivity() : null);
        $notification->setName(method_exists($object, 'getName') ? $object->getName() : $object->__toString());
        $notification->setAction('notification.actions.' . $action);
        $notification->setCreatedBy($this->security->getUser());
        $notification->setObject((object) $normalized);
        $this->notificationRepository->insert($notification);

        if ($users) {
            $nus = $this->notificationRepository->saveUsers($notification, $users);

            $notification->setNotificationUsers($nus);
            $this->notificationRepository->update($notification);
        }

        return $notification;
    }

    private function getObjectSimpleValue($object)
    {
        if (is_object($object)) {
            if (method_exists($object, 'getId')) {
                return $object->getId();
            } elseif (method_exists($object, '__toString')) {
                return $object->__toString();
            } elseif (method_exists($object, 'format')) {
                return $object->format(DATE_ATOM);
            }

            return '';
        }

        return $object;
    }
}
